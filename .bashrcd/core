#! /bin/bash

source ~/.profile

export HISTFILESIZE=
export HISTSIZE=
export HISTCONTROL=ignoredups
export HISTFILE=~/.bash_history_real
shopt -s histappend
PS1='\[\e[1;32m\][\u@\h \W]\$\[\e[0m\] '

alias grep='grep --color=auto'
alias less='less -i'
alias ls='ls --color=auto'
alias ssh='ssh -t'
alias ag='ag -i'

alias v='vim'
alias l='ls'
alias aw='ag -sw'
alias sedr='sed -r'
alias py='python'
alias py2='python2'
alias :q='exit'
alias pb="curl -F 'sprunge=<-' http://sprunge.us"

syntax-highlight () {
    if type -p pygmentize > /dev/null; then
        local args=()
        [ -n "$1" ] && args=(-l "$1")
        pygmentize -f terminal "${args[@]}"
    else
        cat
    fi
}

show () {
    if declare -f "$1" > /dev/null; then
        declare -f "$1" | syntax-highlight bash
    elif alias "$1" &> /dev/null; then
        alias "$1" 2> /dev/null | syntax-highlight bash
    elif [ -n "$(type -p "$1")" ]; then
        local path="$(type -p "$1")"
        if file -biL "$path" | grep -q "^application/"; then
            echo "$path"
        else
            syntax-highlight < "$path"
        fi
    else
        echo >&2 "cannot find '$1'"
        return 1
    fi
}

complete -A alias -A function -A command show

fix-perms () {
    for dir in "$@"; do
        find "$dir" -type d | xargs chmod 755 2> /dev/null
        find "$dir" -type f | xargs chmod 644 2> /dev/null
    done
}

pushd () {
    command pushd "$@" > /dev/null
}

popd () {
    command popd "$@" > /dev/null
}

nhardlinks () {
    if [ -f "$1" ]; then
        ls -l "$1" | awk '{ print $2 }'
    else
        echo 1>&2 "not a file: $1"
        return 1
    fi
}

search () {
    ag -ug "$@"
}

sumfs () {
   ls -l "$@" | awk '{print $5}' | paste -sd+ - | bc
}

# git

git () {
    case "$1" in
    fetch)
        command git fetch -t "${@:2}"
        ;;
    *)
        command git "$@"
        ;;
    esac
}

# get the current git branch name
alias gitbranch='git rev-parse --abbrev-ref HEAD'

gitfirst () {
    git hash-object -t tree /dev/null
}

logorigin () {
    git log "origin/$(git rev-parse --abbrev-ref HEAD)" "$@"
}

gitnew () {
    args=()
    opts=()
    for arg in "$@"; do
       if [[ "$arg" == -* ]]; then
            opts+=("$arg")
        else
            args+=("$arg")
        fi
    done
    [ "${#opts[@]}" -eq 0 ] && opts+=('--oneline')

    if [ "${#args[@]}" -eq 0 ]; then
        remote="origin/$(gitbranch)"
    else
        remote="${args[0]}"
    fi
    git log "${opts[@]}" .."$remote"
}

gitfetchnew () {
    git fetch && gitnew && gitnew --stat
}

# get files changed since the last git commit
gitchanged () {
    git diff --name-only HEAD
}

gitag () {
    git diff --relative -z --name-only HEAD | xargs -0 ag "$@" 2> /dev/null
}

alias gitaw='gitag -sw'

# shows the root directory of the git repository you are in
gitroot () {
    git rev-parse --show-toplevel
}

gitar () {
    name=$(basename "$(readlink -f ..)")
    if [ -z "$2" ]; then
        ext=tar.gz
    else
        ext=$2
    fi
    git archive HEAD --prefix="$name-$1/" -o"../$name-$1.$ext"
}

# update another branch and merge it in
# returns 1 on invalid branch, 2 on stash pop failure, 3 on merge failure
gitmerge () {
    local branch="$1"
    [ -z "$branch" ] && {
        echo 1>&2 "[gitmerge] expected branch to merge as argument"
        return 2
    }
    local rtn=0
    local stash=$(gitchanged)
    local origbranch=$(gitbranch)

    echo 1>&2 "[gitmerge] stash"
    [ -n "$stash" ] && git stash
    echo 1>&2 "[gitmerge] update $branch"
    gitup "$branch"
    rtn="$?"
    git checkout "$origbranch"

    # only merge if pull succeeded
    if [ "$rtn" -eq 0 ]; then
        echo 1>&2 "[gitmerge] merge $branch into $origbranch"
        if git merge "$branch"; then
            echo 1>&2 "[gitmerge] merge succeeded; unstash"
            [ -n "$stash" ] && { git stash pop || rtn=2; }
        else
            echo 1>&2 "[gitmerge] merge failed"
            [ -n "$stash" ] && {
                echo 1>&2 "[gitmerge] WARNING: local changes are still stashed"
            }
            rtn=3
        fi
    else
        echo 1>&2 "[gitmerge] update failed; unstash"
        [ -n "$stash" ] && { git stash pop || rtn=2; }
    fi

    return "$rtn"
}

gitresethard () {
    if [ "$#" -eq 0 ]; then
        gitresethard .
    else
        git reset HEAD -- "$@"
        git checkout HEAD -- "$@"
        git clean -fd -- "$@"
    fi
}

# run before pulling to determine whether a rebase or merge is necessary
gitrebase () {
    local merge=
    local local_changes=
    local remote_changes=
    local current="$(gitbranch)"

    git fetch || return 1

    # check for changes on remote but not local branch
    [ -n "$(git log --oneline "$current"..origin/"$current")" ] && remote_changes=y

    # for each change on local but not remote branch
    for rev in $(git log --format=format:%H origin/"$current".."$current"); do
        local_changes=y
        # branches containing the change, excluding the current local branch
        branches="$(git branch -a --contains "$rev" | grep -v "^*")"
        # should merge if there are any
        if [ -n "$branches" ]; then
            echo 1>&2 "new local commit $rev is contained in branches:"
            echo 1>&2 "$branches"
            echo 1>&2
            merge=y
            break
        fi
    done

    if [ -z "$local_changes" ]; then
        echo "no local changes"
    elif [ -z "$remote_changes" ]; then
        echo "no remote changes"
    elif [ -n "$merge" ]; then
        echo "merge"
    else
        echo "rebase"
    fi
}

# switch to another branch and pull, preserving uncommitted changes
# returns 1 on checkout failure, 2 on stash pop failure
gitup () {
    local rtn=0
    local stash=$(gitchanged)
    [ -n "$stash" ] && git stash
    [ -n "$1" ] && {
        git checkout "$1" || {
            git fetch
            git checkout "$1" || rtn=1
        }
    }
    [ "$rtn" = 0 ] && {
        local action="$(gitrebase)" || rtn=1
        case "$action" in
            "no local changes"|merge)
                git pull || rtn=1
                ;;
            rebase)
                git pull --rebase || rtn=1
                ;;
        esac
    }
    [ -n "$stash" ] && { git stash pop || rtn="${rtn:-2}"; }
    return "$rtn"
}

links () {
    local http_proxy_args=()
    [ -n "$http_proxy" ] && http_proxy_args=(-http-proxy "${http_proxy##*/}")
    local https_proxy_args=()
    [ -n "$https_proxy" ] && \
        https_proxy_args=(-https-proxy "${https_proxy##*/}")
    command links "${http_proxy_args[@]}" "${https_proxy_args[@]}" "$@"
}
